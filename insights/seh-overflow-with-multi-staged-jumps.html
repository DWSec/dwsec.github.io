<!DOCTYPE html><!-- Last Published: Fri Jan 12 2024 08:39:01 GMT+0000 (Coordinated Universal Time) --><html data-wf-page="6572f99ba87060097855250a" data-wf-site="63b6d5e577ebd8b19dbf7bfe" data-wf-collection="6572f99ba87060097855251a" data-wf-item-slug="seh-overflow-with-multi-staged-jumps"><head><meta charset="utf-8"/><title>Dark Waves Infosec Ltd</title><meta content="width=device-width, initial-scale=1" name="viewport"/><link href="../css/dwsec.webflow.1049a7f6a.min.css" rel="stylesheet" type="text/css"/><script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script><link href="../images/favicon.png" rel="shortcut icon" type="image/x-icon"/><link href="../images/app-icon.png" rel="apple-touch-icon"/></head><body><div data-animation="default" data-collapse="medium" data-duration="400" data-easing="ease" data-easing2="ease" role="banner" class="navbar w-nav"><div class="container navbar-container"><a href="/" class="home-link w-inline-block"><img src="../images/02-white-isologotype-403x.png" loading="lazy" width="150" sizes="(max-width: 479px) 90px, (max-width: 767px) 120px, 150px" alt="" srcset="../images/02-white-isologotype-403x-p-500.png 500w, ../images/02-white-isologotype-403x-1.png 901w" class="logo"/></a><div class="menu-button w-nav-button"><div class="w-icon-nav-menu"></div></div><nav role="navigation" class="nav-menu w-nav-menu"><div class="navbar-menu-items"><a href="/about-us" class="nav-link w-inline-block"><div>About us</div><div class="nav-link-line"></div></a><a href="/services" class="nav-link w-inline-block"><div>Services</div><div class="nav-link-line"></div></a><a href="/insights" class="nav-link w-inline-block"><div>Insights</div><div class="nav-link-line"></div></a><a href="#" class="button navbar-button w-button">Contact us</a></div></nav></div></div><div class="section insight-template"><div class="scroll-indicator scroll_indicator"></div><div class="container centered"><div class="insight-header-image-contain"><div class="insight-title-wrap"><h2 class="insight-title">SEH Overflow with Multi-Staged Jumps</h2><div class="insight-date">June 26, 2020</div></div><div style="background-image:url(&quot;../images/img0-1.webp&quot;)" class="insight-header-image"></div></div><div class="insight-post-contain"><div class="inisght-rich-text-block w-richtext"><p>This blog post is not original. All exploits examined here are taken directly from Fu11pwnops’ Windows Exploitation Pathway series. It merely covers my experience — what I learned and what confused me while completing this tutorial:</p><p>‍</p><h4><a href="https://fullpwnops.com/CVE-2019-17181-intrasrv-writeup/?ref=dwsec-blog">https://fullpwnops.com/CVE-2019-17181-intrasrv-writeup/</a></h4><h4><a href="https://fullpwnops.com/CVE-2019-17181-intrasrv-writeup/?ref=dwsec-blog">‍</a><br/></h4><p>This exploit pops a calculator after a malicious HEAD request is sent to the vulnerable application triggering a SEH overflow.</p><p>Our target application is an IntraSRV web-server that contains a buffer overflow vulnerability when processing HTTP HEAD requests. I completed this tutorial on a Windows 7 64-bit virtual machine.<br/></p><p>Let’s start by running IntraSrv and attaching it to the Immunity debugger:</p><p>‍</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="../images/img1.webp" loading="lazy" alt=""/></div></figure><p>‍</p><p>Next, let’s send a malicious payload to the server using a Python script. When we spin up IntraSrv it tells us what port and IP address it’s listening on.</p><p>‍</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="../images/img2.webp" loading="lazy" alt=""/></div></figure><p>‍</p><p>Now for our script:</p><p>‍</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="../images/img3.1.png" loading="lazy" alt=""/></div></figure><p>‍</p><p>When we execute this script, we can see in immunity that registers are overwritten and our SEH chain is corrupted:</p><p><br/></p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="../images/img4.webp" loading="lazy" alt=""/></div></figure><p>‍</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="../images/img5.webp" loading="lazy" alt=""/></div></figure><p>‍</p><p>The address of the handler gets overwritten with 41414141 which are the ASCII codes for “A”. When control tries to jump to this address we get an “access violation.”</p><p>Important to remember that the SEH chain is a linked list. The address of the first SEH entry is pointed to by the “thread information block at offset 0,” (resources.infosecinstitute.com). Each record in the list contains the address of the code routine defined to handle the raised exception. When a program experiences an exception, the operating system “attempts to pass control to the code located at the address specified in the SEH list,” (resources.infosecinstitute.com). A common way to prevent an SEH based overflow is by not having any valid POP POP RET sequences in the code. You can render such a sequences useless by including a NULL byte in them. If there’s not a valid POP POP RET sequence you’ll be unable to exploit the SEH overflow.</p><p>Back to our exploit.</p><p>Now that we’ve confirmed a vulnerability exists we need to calculate the size of the input buffer. We can do this using Metasploit’s pattern_create tool.</p><p>‍</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="../images/img6.webp" loading="lazy" alt=""/></div></figure><p>‍</p><p>Now, let’s send this pattern to the buffer instead of our random string of A’s.</p><p>‍</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="../images/img7.webp" loading="lazy" alt=""/></div></figure><p>‍</p><p>We can then run the !mona findmsp command to find instances of a cyclic pattern (a.k.a our Metasploit pattern). Note: you have to actually crash the application (IntraSrv in this case) to be able to run the findmsp command. We can see registers being overwritten by our cyclic pattern.</p><p>‍</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="../images/img8.webp" loading="lazy" alt=""/></div></figure><p>‍</p><p>Now that we know where the SEH and NSEH handlers are, we can overwrite them:</p><p>‍</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="../images/img7.1.png" loading="lazy" alt=""/></div></figure><p>‍</p><p>I’m not completely sure why Fu11pwn fills the buffer with an extra 439 “D” characters after he overwrites the SEH and NSEH handlers…</p><p>At this point we want to use the “!mona seh -n” command to locate a POP POP RET sequence to escape the SEH chain and get to our shellcode. Unfortunately, there are no pointers without NULL bytes. Including NULL bytes in all POP POP RET gadgets is a common defense against SEH overflow attacks. However, according to Fullpwnops, even with NULL bytes the attack sometimes still works (fu11pwnops.com).</p><p>The whole point of multi-staged jmp exploits is to allow the attacker to escape a restricted buffer space and give the attacker enough room on the stack to insert the malicious shell code. The latter part of this is crucial as a shellcode injection can easily takeup 300 bytes. Typically, multi-staged jumps work by jumping the attacker forwards or backwards a small amount and then jumping the attacker back a large amount so he/she is (1) out of the protected buffer and (2) can execute his / her shellcode.</p><p>Another way to handle the same situation is using an “egg hunter.” An egg hunter is a small piece of shellcode which searches through memory for a larger piece of shellcode that the attacker injected in an alternate location in memory with more space (secpod.com). The egg hunter jumps execution flow to that location. Attackers teach their hunter to search for an “EGG” which is a “unique string of 8 bytes made up of combining two “TAG’s,” (secpod.com). The EGG is placed right before the shellcode in memory.</p><p>Upon reading this, I immediately wondered why we didn’t just inject a jump instruction into the buffer which could jump us to the shellcode we wanted to execute instead of using an egg hunter to find that shellcode. One of the key reasons to use an egg hunter is because the vulnerable buffer / area you’re trying to exploit is not large enough to hold the shellcode you’re trying to inject. In this circumstance it makes sense to put your shellcode in a different part of memory where there’s room for it. However, I didn’t completely understand why you need to search through memory to find your shellcode. Why wouldn’t you know where the shellcode is in memory (or be able to figure it out) and then just jump to it?</p><p>This question forced me to go back and learn about buffer overflow protection methods. Here are a few of the most basic precautions:</p><p>Canary: Named after the saying “canary in the coal mine,” stack canaries are small integers, randomly chosen at program start, which are put on the stack right before the return pointer (en.wikipedia.org). The canary has to be checked and validated before the EIP register can execute the return instruction on the stack. If the canary gets overwritten, “execution of the affected program can be terminated” (wikipedia) preventing the attacker from taking control and acting maliciously.</p><p>There are three common and different implementations of canaries: terminator canaries, random canaries, and random XOR canaries.</p><p>Terminator canaries:</p><p>Terminator canaries are based on the observation that most buffers are overflowed by strings which are terminated by a null byte. So, terminator canaries protect against certain functions like strcpy() that return upon encountering a NULL byte. This kind of canary can be bypassed if the attacker uses a function that does not return upon encountering a NULL byte and if the attacker writes the correct canary value into the correct memory location so canary validation passes.</p><p>Random canaries:</p><p>A random canary is chosen at the time the program executes. The obvious perk here is that the attacker doesn’t know the canary value. The random value is taken from the /dev/urandom file which serves as a pseudorandom number generator (access.redhat.com).</p><p>This method of canary defense can be compromised if the attacker is somehow able to view the application code and uncover the value of the canary.</p><p>Random XOR canaries:</p><p>Random XOR canaries are random canaries that are “XOR scrambled using part or all of the control data (frame pointer + return address etc),” (access.redhat.com). This method of canary protection requires the attacker to have the original canary (which he/she would theoretically need an information leak to obtain) the algorithm used to XOR scramble the canary, and the original control data used to scramble the canary. For all the reasons mentioned, XOR canaries are more difficult to exploit than terminator or random canaries. Furthermore, XOR canaries offer some protection from attacks that overwrite control data. Since the control data is used to scramble the canary, if the control data is modified, the new canary won’t match the original canary value.</p><p>Bounds checking:</p><p>Bounds checking is another measure designed to offset buffer overflows. This method adds “run-time information for each allocated block of memory, and checks all pointers against those at run-time” (en.wikipedia.org).</p><p>There are two common specific kinds of bounds checks:</p><p>Range checking: Check that a number about to be assigned to a variable is within a the range of what that variable can hold.</p><p>Index checking: In all expressions indexing an array the index value is “checked against the bounds of the array,” (wikipedia.org).</p><p>However, because bounds checking requires the program to check that each entry is valid, processing power is required. Consequently, many languages, like C, do not include any bounds checking, and programmers can disable said checks in languages that do have them to optimize for speed.</p><p>Tagging / Non-executable stack :</p><p>Tagging is another common memory exploitation defense which centers involves marking certain areas of memory as non-executable. This effectively prevents memory designated to store data from executing code. Attackers will be unable to inject and run their shellcode in a non-executable region and will either have to find a way to “disable the execution protection from memory, or find a way to put their shellcode payload in a non-protected region of memory,” (wikipedia.org). This is precisely the situation we’re dealing with in this article by implementing a multi-staged jump to jump out of a protected memory space and into an unprotected area where we injected our shellcode.</p><p>Randomization:</p><p>Unlike tagging which try’s to separate code from data, randomization simply introduces “randomization” to the programs memory space. This technique will “prevent the attacker from knowing where any code is,” (wikipedia.org) and make jumping to attacker injected shellcode or constructing a ROP chain considerably more difficult. Address space layout randomization (ASLR) presents one use case for the concept of using egg hunters to find shellcode since you wouldn’t know where to jump control to and would need to locate your shellcode in memory.</p><p>‍</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="../images/img9.webp" loading="lazy" alt=""/></div></figure><p>‍</p><p>Let’s get back to the multi-stage jump exploit.</p><p>Fu11pwnops decided that an egg hunter was not necessary for this exploit as ASLR is disabled:</p><p>‍</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="../images/img10.webp" loading="lazy" alt=""/></div></figure><p>‍</p><p>Here is what the final exploit looks like:</p><p>‍</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="../images/img.11.png" loading="lazy" alt=""/></div></figure><figure class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="../images/img.12.png" loading="lazy" alt=""/></div></figure><p>‍</p><p>The above exploit is taken directly from Fu11pwnops’ article and uses msfvenom to generate shellcode that will pop a calculator when the HEAD request is processed.</p><p>Hopefully this post provided you with an understanding of some of the most fundamental protections against buffer overflows and some of the maneuvers (multi-staged jumps, egg hunters, etc) we can deploy to get around them.</p><p>‍</p></div></div></div></div><div class="section more-insights"><div class="container"><div class="insights-header-flex no-left-padding"><h2 class="dark-text">Explore more insights</h2></div><div class="insights-list-wrapper w-dyn-list"><div role="list" class="insights-list w-dyn-items"><div role="listitem" class="insight-item more w-dyn-item"><a href="/insights/expanding-our-windbg-arsenal-handleex-extension" class="insight-link-block w-inline-block"><div class="insight-card"><div class="card-left"><img alt="" loading="lazy" width="88" src="../images/01-white-isotype-40png-1.png" class="card-logo-image"/><div class="card-title-text">Expanding Our WinDBG Arsenal - Handleex Extension</div></div><div style="background-image:url(&quot;../images/extensioninaction.png&quot;)" class="card-right"></div></div><h2 class="card-title _30px">Expanding Our WinDBG Arsenal - Handleex Extension</h2><div class="publish-date">May 11, 2023</div></a></div><div role="listitem" class="insight-item more w-dyn-item"><a href="/insights/think-offensive-leverage-osquery-for-discovery-and-enumeration" class="insight-link-block w-inline-block"><div class="insight-card"><div class="card-left"><img alt="" loading="lazy" width="88" src="" class="card-logo-image w-dyn-bind-empty"/><div class="card-title-text">Think Offensive - Leverage OSQuery for Discovery and Enumeration</div></div><div style="background-image:url(&quot;../images/osquery-1.jpeg&quot;)" class="card-right"></div></div><h2 class="card-title _30px">Think Offensive - Leverage OSQuery for Discovery and Enumeration</h2><div class="publish-date">June 29, 2023</div></a></div><div role="listitem" class="insight-item more w-dyn-item"><a href="/insights/asm-1-tutorial-absolute-basics" class="insight-link-block w-inline-block"><div class="insight-card"><div class="card-left"><img alt="" loading="lazy" width="88" src="../images/01-white-isotype-40png-1.png" class="card-logo-image"/><div class="card-title-text">ASM 1 Tutorial: Absolute Basics</div></div><div style="background-image:url(&quot;../images/img0.webp&quot;)" class="card-right"></div></div><h2 class="card-title _30px">ASM 1 Tutorial: Absolute Basics</h2><div class="publish-date">July 14, 2020</div></a></div><div role="listitem" class="insight-item more w-dyn-item"><a href="/insights/exploiting-millennium-mp3-studio-2-0-with-shellcode-payload" class="insight-link-block w-inline-block"><div class="insight-card"><div class="card-left"><img alt="" loading="lazy" width="88" src="../images/01-white-isotype-40png-1.png" class="card-logo-image"/><div class="card-title-text">Exploiting Millennium MP3 Studio 2.0 with Shellcode Payload</div></div><div style="background-image:url(&quot;../images/img0-2.webp&quot;)" class="card-right"></div></div><h2 class="card-title _30px">Exploiting Millennium MP3 Studio 2.0 with Shellcode Payload</h2><div class="publish-date">June 8, 2020</div></a></div></div></div></div></div><div id="Footer" class="section footer"><div class="container"><h2 data-w-id="ae4b8e71-0363-414c-edd7-c73018081b98" class="large-text footer-heading">Security You Can Trust</h2><div class="footer-content-contain"><div class="footer-flex"><div class="footer-left"><p data-w-id="ae4b8e71-0363-414c-edd7-c73018081b9d">As we are passionate about this industry, security and research comes as a second nature for us providing our customers with unmatched results. Let&#x27;s get in touch!</p><div class="footer-contact-links-wrap"><a data-w-id="ae4b8e71-0363-414c-edd7-c73018081ba0" href="#" class="link-block w-inline-block"><div class="link-block-left"><img src="../images/free-mail-icon-142-thumb.png" loading="eager" width="20" alt="" class="contact-icon"/><div class="contact-type">Email</div></div><div class="link-block-center"><div class="contact-symbol">@</div></div><div class="link-block-right"><div class="contact">hello@darkwaves.io</div></div><div class="link-block-border"><div class="link-block-hover-border"></div></div></a><a data-w-id="ae4b8e71-0363-414c-edd7-c73018081bad" href="https://twitter.com/DarkWaves_Sec" target="_blank" class="link-block w-inline-block"><div class="link-block-left"><img src="../images/81609.png" loading="eager" width="20" sizes="20px" alt="" srcset="../images/81609-p-500.png 500w, ../images/81609-1.png 512w" class="contact-icon"/><div class="contact-type">Twitter</div></div><div class="link-block-center"><img src="../images/contact-20arrow.svg" loading="lazy" width="16" alt="" class="contact-arrow"/></div><div class="link-block-right"><div class="contact">@DarkWaves_Sec</div></div><div class="link-block-border"><div class="link-block-hover-border"></div></div></a><a data-w-id="ae4b8e71-0363-414c-edd7-c73018081bb9" href="https://www.linkedin.com/company/dwsec" target="_blank" class="link-block w-inline-block"><div class="link-block-left"><img src="../images/174857.png" loading="eager" width="20" sizes="20px" alt="" srcset="../images/174857-p-500.png 500w, ../images/174857-1.png 512w" class="contact-icon"/><div class="contact-type">LinkedIn</div></div><div class="link-block-center"><img src="../images/contact-20arrow.svg" loading="lazy" width="16" alt="" class="contact-arrow"/></div><div class="link-block-right"><div class="contact">@dwsec</div></div><div class="link-block-border"><div class="link-block-hover-border"></div></div></a></div></div><div class="footer-right"><h3 data-w-id="ae4b8e71-0363-414c-edd7-c73018081bde" class="footer-address">DARK WAVES INFOSEC LTD<br/>71-75 Shelton Street<br/>Covent Garden<br/>London<br/>WC2H 9JQ</h3><div class="_20px-height-gap-div"></div><div data-w-id="ae4b8e71-0363-414c-edd7-c73018081be5" class="copyrights">Copyright © Dark Waves Infosec LTD.<br/></div></div></div></div></div></div><script src="../js/jquery.js" type="text/javascript"  ></script><script src="../js/webflow-script.js" type="text/javascript"></script></body></html>